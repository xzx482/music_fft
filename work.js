
var 离屏画布,画布;

var 列=[];

var 画布高,画布宽;

var 音频数组

var 音频数组大小,幂;

var 更新列=()=>{
	列.length=0;
	var 音数引,音数引_旧,x_旧,b,dot,x,j,k;
	x_旧=0;
	for(x=0;x<画布宽;x++){
		音数引=parseInt(非参1*x**幂);//对应的音频数组下标
		列.push({
			y:0,//高度
			v:0,//速度
			zy:0,//矩形高度
			音数引:音数引,//音频数组下标
			b:0//两种情况, 分别对应不同的意义, 详见下方 if(非导参1>x){...}else{...} 的两种情况
		});
	}
	for(var x=0;x<列.length;x++){
		dot=列[x];
		音数引=dot.音数引;
		if(非导参1>x){
            //多个像素有一个音频数据量

			if(音数引==音数引_旧){

			}else{
                //找到 一个音频数据量 的 开始和结束 的像素 位置
                //对于其中的每个像素, 分配其 左右两个 不同的音频数据量 的 加权平均数, 越左边的像素 对左边的 音频数据量 权重越大
                //b即为右边的权重, 左边的权重为1-b
				k=x-x_旧;
				for(j=0;j<k;j++){
					b=j/k;
					列[j+x_旧].b=b;
				}
				x_旧=x
			}
			音数引_旧=音数引
		}else{
            //一个像素有多个音频数据量
            //b为 音频数据量 的个数
			dot.b=音数引-列[x-1].音数引;
		}
	}
}

//非线性(二次函数)频谱; 自变量 画布宽, 因变量 音频数组大小
// 音频数组大小=非参1*画布宽**幂;
// 对其求导
//音频数组大小'=幂*非参1*画布宽'**(幂-1)
//计算斜率为1时的 画布的x坐标, 名为 非导参1
// 1=幂*非参1*非导参1**(幂-1)
//非导参1**(幂-1)=1/幂/非参1
//非导参1=(1/(幂)/非参1)**(1/(幂-1)) //此时一个像素正好是一个音频数据量;横坐标小于它时,多个像素有一个音频数据量;大于它时,一个像素有多个音频数据量
var 非参1=0;
var 非导参1=0;
var 音数对高;

更新非线性参数=()=>{
	非参1=音频数组大小/画布宽**幂;
	非导参1=(1/幂/非参1)**(1/(幂-1));
	if(非导参1<1){
		非导参1=1;
	}

	更新列();

}


var 适应大小=()=>{
	离屏画布.width=画布宽;
	离屏画布.height=画布高;
}





var 现在时间,帧数,帧率,帧率时间,延迟时间,绘制时间;
帧数=0;
帧率时间=0;


var x,条高,o,j,总和,最大;
var 粒高=1//粒子高度

var 绘制=(音频数组)=>{

    绘制时间=performance.now();

	画布.clearRect(0,0,画布宽,画布高);
	画布.font = "20px Arial";//清空后需重新设置字体等
    
	for(x=0;x<画布宽;x++){
		o=列[x];

		if(o.b){
			if(非导参1>x){
				条高=音数对高*(音频数组[o.音数引]*(1-o.b)+音频数组[o.音数引+1]*o.b);
			}else{
				/*
				//平均值
				总和=0;
				for(j=o.音数引;j>o.音数引-o.b;j--){
					总和+=音频数组[j];
				}
				条高=总和/o.b*音数对高;
				/*/
				//最大值
				最大=0;
				for(j=o.音数引;j>o.音数引-o.b;j--){
					if(音频数组[j]>最大){
						最大=音频数组[j];
					}
				}
				条高=最大*音数对高;
                //*/
			}
		}else{
			条高=音频数组[o.音数引]*音数对高;
		}
		
        
		画布.fillStyle="#00000077";
		画布.fillRect(x,画布高-条高,1,条高);

		//*
		
		画布.fillStyle="#000000ff";


		//小方块匀加速下落

		if(o.y<条高){
			o.y=条高;
			o.v=(条高-o.zy)*0.3-o.v*0.2;//碰撞后反弹, 损失一定速度
		}
		if(o.y>画布高){
			o.y=画布高-2;
			o.v=-o.v*0.5;//碰顶反弹
		}
		o.v-=0.4;//重力加速度
		o.y+=o.v;
		o.zy=条高;
		画布.fillRect(x,画布高-(o.y+粒高),1,粒高);
		//*/
	}
    现在时间=performance.now();
	//*
	帧数++;
	if(帧数==32){
		帧数=0;
		帧率=32/(现在时间-帧率时间)*1000;
		帧率时间=现在时间;
	}
	//ctx.fillStyle = "white";
	画布.fillText("FPS:"+Math.round(帧率),画布宽-80,20);
	
	//*/
    
	画布.fillText(parseInt(现在时间-绘制时间).toString().padStart(2,'0')+'ms',画布宽-140,20);
	
	画布.fillText(parseInt(现在时间-延迟时间).toString().padStart(2,'0')+'ms',画布宽-200,20);
	延迟时间=现在时间;

    //画布.fillText(String(音频关联.outputLatency).padStart(2,'0')+'ms',画布宽-320,20);
    //画布.fillText(String(音频关联.baseLatency).padStart(2,'0')+'ms',画布宽-400,20);
	//*/
}




onmessage=(e)=>{
    var data=e.data;
    switch(data[0]){
        case 0://转移音频数组并绘制
            音频数组=data[1];
            绘制(音频数组);
            postMessage([1,音频数组],[音频数组.buffer]);
            break;

        case 1://适应大小
            画布宽=data[1];
            画布高=data[2];
            音数对高=data[3];
            适应大小();
            break;
        case 2://更新非线性参数
            音频数组大小=data[1];
            幂=data[2];
            更新非线性参数();
            break;
        case 3://转移画布
            离屏画布=data[1];
            画布=离屏画布.getContext("2d");
            break;

    }
}